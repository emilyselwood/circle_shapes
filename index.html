<!DOCTYPE html>
<html>

<head>
    <title>Patterns</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
        }

        body {
            height: 100vh;
            width: 100vw;
        }

        * {
            box-sizing: border-box;
        }


        .row {
            display: flex;
            flex-wrap: wrap;

            height: 100%;
            padding: 10px;
        }

        .canvasContainer {
            flex: 100%;

        }

        .controlContainer {
            flex: 100%;
            max-height: 100%;
            overflow-y: scroll;

            border: 1px;
            border-style: solid;
            border-radius: 5px;
            border-color: black;
            padding: 5px;

            background-color: lightskyblue;
            font-size: 3em;
        }

        @media (min-aspect-ratio: 1/1) {
            .canvasContainer {
                flex: 75%;
                height: 100%;
            }

            .controlContainer {
                flex: 25%;
                font-size: 1.5em;
            }
        }

        .button {
            width: 100%;
            border: 1px;
            border-style: solid;
            border-radius: 5px;
            text-align: center;

            cursor: pointer;

            border-color: black;
            background-color: aquamarine;

            margin-top: 5px;
            padding: 10px;
        }
    </style>

    <script>

        class InputRangeField extends HTMLElement {

            static observedAttributes = ["heading", "minvalue", "maxvalue", "initalvalue"];

            constructor() {
                super();
                this.heading = "";
                this.minvalue = 0;
                this.maxvalue = 100;
                this.initalvalue = 6;
                this.inputEl = null;
            }

            attributeChangedCallback(name, oldValue, newValue) {
                if (name == "heading") {
                    this.heading = newValue;
                }

                if (name == "minvalue") {
                    this.minvalue = newValue;
                }

                if (name == "maxvalue") {
                    this.maxvalue = newValue;
                }

                if (name == "initalvalue") {
                    this.initalvalue = newValue;
                }
            }

            connectedCallback() {

                const div_element = document.createElement("div");

                const label = document.createElement("label");
                label.innerText = this.heading;
                label.for = this.heading;

                div_element.appendChild(label);

                const value = document.createElement("span");
                value.innerText = this.initalvalue;

                this.inputEl = document.createElement("input");

                this.inputEl.type = "range";
                this.inputEl.min = this.minvalue;
                this.inputEl.max = this.maxvalue;
                this.inputEl.value = this.initalvalue;
                this.inputEl.name = this.heading;

                this.inputEl.addEventListener("input", (event) => {
                    value.textContent = event.target.value;
                    update_drawing();
                });

                div_element.appendChild(this.inputEl);
                div_element.appendChild(value);

                const shadow = this.attachShadow({ mode: "open" });

                shadow.append(div_element);
            }

            getValue() {
                return Number(this.inputEl.value);
            }

            setValue(value) {
                this.inputEl.value = value;
            }
        }

        customElements.define('input-range-field', InputRangeField);

        class InputColourPicker extends HTMLElement {
            static observedAttributes = ["heading", "initalvalue"];
            constructor() {
                super();
                this.heading = "";
                this.initalvalue = "#000000";
                this.colourPickerEl = null;
            }

            attributeChangedCallback(name, oldValue, newValue) {
                if (name == "heading") {
                    this.heading = newValue;
                }
            }

            connectedCallback() {
                const styleEl = document.createElement("style");

                const divEl = document.createElement("div");

                const label = document.createElement("label");
                label.innerText = this.heading;
                label.for = this.heading;

                divEl.appendChild(label);

                this.colourPickerEl = document.createElement("input");
                this.colourPickerEl.type = "color";
                this.colourPickerEl.name = this.heading;
                this.colourPickerEl.value = this.initalvalue;

                this.colourPickerEl.addEventListener("input", (event) => {
                    update_drawing();
                });

                divEl.appendChild(this.colourPickerEl);

                const shadow = this.attachShadow({ mode: "open" });

                shadow.append(divEl);
            }

            getValue() {
                return this.colourPickerEl.value;
            }

            setValue(value) {
                this.colourPickerEl.value = value;
            }
        }

        customElements.define('input-colour-picker', InputColourPicker);

        class ElementControlForm extends HTMLElement {

            static observedAttributes = ["initialData"]

            constructor() {
                super();
                this.initialData = {
                    "shape_corners": 6,
                    "shape_radius": 5,
                    "shape_rotation": 0,
                    "loop_radius": 5,
                    "loop_count": 6,
                    "loop_rotation": 0,
                    "colour": "#000000"
                };
                this.shape_corners = null;
                this.shape_radius = null;
                this.shape_rotation = null;
                this.loop_radius = null;
                this.loop_count = null;
                this.loop_rotation = null;
                this.colour_picker = null;
            }

            attributeChangedCallback(name, oldValue, newValue) {
                if (name == "initialData") {
                    this.initialData = newValue;
                }
            }

            connectedCallback() {
                const styleEl = document.createElement("style");
                styleEl.textContent = `
                    * {
                        box-sizing: border-box;
                    }
                    .elementForm {
                        width: 100%;
                        border: 1px;
                        border-style: solid;
                        border-radius: 5px;
                        border-color: black;

                        padding: 5px;
                    }

                    .deleteButton {
                        width: 100%;
                        border: 1px;
                        border-style: solid;
                        border-radius: 5px;
                        text-align: center;

                        cursor: pointer;

                        border-color: black;
                        background-color: aquamarine;

                    }
                `

                const divEl = document.createElement("div");
                divEl.classList.add("elementForm");

                this.shape_corners = document.createElement("input-range-field");
                this.shape_corners.heading = "Shape Corners";
                this.shape_corners.minvalue = 3;
                this.shape_corners.maxvalue = 20;
                this.shape_corners.initalvalue = this.initialData["shape_corners"];

                divEl.appendChild(this.shape_corners);

                this.shape_radius = document.createElement("input-range-field");
                this.shape_radius.heading = "Shape Radius";
                this.shape_radius.minvalue = 1;
                this.shape_radius.maxvalue = 100;
                this.shape_radius.initalvalue = this.initialData["shape_radius"];

                divEl.appendChild(this.shape_radius);

                this.shape_rotation = document.createElement("input-range-field");
                this.shape_rotation.heading = "Shape rotation";
                this.shape_rotation.minvalue = 0;
                this.shape_rotation.maxvalue = 360;
                this.shape_rotation.initalvalue = this.initialData["shape_rotation"];

                divEl.appendChild(this.shape_rotation);

                this.loop_radius = document.createElement("input-range-field");
                this.loop_radius.heading = "Loop Radius";
                this.loop_radius.minvalue = 0;
                this.loop_radius.maxvalue = 100;
                this.loop_radius.initalvalue = this.initialData["loop_radius"];

                divEl.appendChild(this.loop_radius);

                this.loop_count = document.createElement("input-range-field");
                this.loop_count.heading = "Loop Count";
                this.loop_count.minvalue = 1;
                this.loop_count.maxvalue = 20;
                this.loop_count.initalvalue = this.initialData["loop_count"];

                divEl.appendChild(this.loop_count);

                this.loop_rotation = document.createElement("input-range-field");
                this.loop_rotation.heading = "Loop rotation";
                this.loop_rotation.minvalue = 0;
                this.loop_rotation.maxvalue = 360;
                this.loop_rotation.initalvalue = this.initialData["loop_rotation"];

                divEl.appendChild(this.loop_rotation);

                this.colour_picker = document.createElement("input-colour-picker");
                this.colour_picker.heading = "Colour";
                this.colour_picker.initalvalue = this.initialData["colour"];

                divEl.appendChild(this.colour_picker);

                const deleteButton = document.createElement("div");
                deleteButton.innerText = "delete";
                deleteButton.classList.add("deleteButton");

                const customElement = this;
                deleteButton.addEventListener("click", function (e) {
                    customElement.parentElement.removeChild(customElement);
                    update_drawing();
                })

                divEl.appendChild(deleteButton);

                const shadow = this.attachShadow({ mode: "open" });

                shadow.append(styleEl);
                shadow.append(divEl);
            }

            getValues() {
                return {
                    "shape_corners": this.shape_corners.getValue(),
                    "shape_radius": this.shape_radius.getValue(),
                    "shape_rotation": this.shape_rotation.getValue(),
                    "loop_radius": this.loop_radius.getValue(),
                    "loop_count": this.loop_count.getValue(),
                    "loop_rotation": this.loop_rotation.getValue(),
                    "colour": this.colour_picker.getValue()
                };
            }

        }

        customElements.define('element-control-form', ElementControlForm);

        function loopValuesToSave(values) {
            return {
                "c": values["shape_corners"],
                "r": values["shape_radius"],
                "o": values["shape_rotation"],
                "a": values["loop_radius"],
                "u": values["loop_count"],
                "e": values["loop_rotation"],
                "l": values["colour"],
            }
        }

        function encodeSaveData(data) {
            const jsoned = JSON.stringify(data);
            const payload = btoa(jsoned);

            let existingParams = new URLSearchParams(document.location.search);
            existingParams.set("shapes", payload);
            const result = document.location.protocol + "//" + document.location.host
                + document.location.pathname + "?" + existingParams.toString();

            return result;
        }



        function saveToLoopValues(save) {
            return {
                "shape_corners": save["c"],
                "shape_radius": save["r"],
                "shape_rotation": save["o"],
                "loop_radius": save["a"],
                "loop_count": save["u"],
                "loop_rotation": save["e"],
                "colour": save["l"]
            }
        }

        function decodeSaveData(payload) {
            const rawJson = atob(payload);
            const data = JSON.parse(rawJson);
            let result = [];
            for (let i = 0; i < data.length; i++) {
                result.push(saveToLoopValues(data[i]));
            }

            return result;
        }

        function create_svg(svgEl, data) {
            const rootGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
            rootGroup.setAttribute("transform", "translate(200, 200)");

            for (let i = 0; i < data.length; i++) {
                const loopValues = data[i];

                const loopGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
                loopGroup.setAttribute("transform", "rotate(" + loopValues["loop_rotation"] + ")");
                const loopStep = 360 / loopValues["loop_count"];
                for (let l = 0; l < loopValues["loop_count"]; l++) {
                    const shapeGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
                    shapeGroup.setAttribute("transform", "rotate(" + (loopStep * l) + ")");

                    // draw the shape...
                    const shapeEl = document.createElementNS("http://www.w3.org/2000/svg", "path");

                    const shapeStep = (2 * Math.PI) / loopValues["shape_corners"];
                    const shapeStart = ((2 * Math.PI) / 360) * loopValues["shape_rotation"];
                    let path = "";
                    for (let s = 0; s < loopValues["shape_corners"]; s++) {
                        const angle = (s * shapeStep) + shapeStart;
                        const x = (0 * Math.cos(angle)) - (loopValues["shape_radius"] * Math.sin(angle));
                        const y = (loopValues["shape_radius"] * Math.cos(angle)) + (0 * Math.sin(angle));
                        if (s == 0) {
                            path = path + "M" + x + " " + (y + loopValues["loop_radius"]);
                        } else {
                            path = path + " L" + x + " " + (y + loopValues["loop_radius"]);
                        }
                    }

                    path = path + "Z";

                    shapeEl.setAttribute("d", path);
                    shapeEl.setAttribute("stroke", loopValues["colour"]);

                    shapeGroup.appendChild(shapeEl);

                    loopGroup.appendChild(shapeGroup);
                }

                rootGroup.appendChild(loopGroup);
            }

            svgEl.appendChild(rootGroup);
        }

        function update_drawing() {
            const parentEl = document.getElementById("controls");
            const imageEl = document.getElementById("image_root");

            // Clear the existing elements.
            while (imageEl.firstChild) {
                imageEl.removeChild(imageEl.lastChild);
            }

            const rootGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
            rootGroup.setAttribute("transform", "translate(200, 200)");

            var saveData = [];
            var data = [];

            var children = parentEl.children;
            for (var i = 0; i < children.length; i++) {
                var child = children[i];

                const loopValues = child.getValues();
                console.log(loopValues);

                saveData.push(loopValuesToSave(loopValues));
                data.push(loopValues);
            }

            create_svg(imageEl, data);

            const newUrl = encodeSaveData(saveData);
            if (newUrl != document.location.toString()) {
                window.history.replaceState({ path: newUrl }, "", newUrl);
            }
        }

        function add_element() {
            const parentEl = document.getElementById("controls");

            const new_control = document.createElement("element-control-form");

            parentEl.appendChild(new_control);

            update_drawing();
        }

        function download() {
            const svg = document.getElementById("image_root");
            const svg_xml = (new XMLSerializer).serializeToString(svg);

            const blob = new Blob([svg_xml], { type: "image/svg+xml" });
            const blobURL = URL.createObjectURL(blob);
            const a = document.createElement('a');

            a.setAttribute('href', blobURL);
            a.setAttribute('download', 'circle_shapes.svg');
            a.style.display = 'none';
            document.body.appendChild(a);

            a.click();

            document.body.removeChild(a);
            URL.revokeObjectURL(blobURL);
        }

        function clear_loops() {
            console.log("clearing all loops");
            const parentEl = document.getElementById("controls");
            // Clear the existing elements.
            while (parentEl.firstChild) {
                parentEl.removeChild(parentEl.lastChild);
            }

            update_drawing();
        }

        function setup() {
            const params = new URLSearchParams(document.location.search);
            const payload = params.get("shapes");
            if (payload) {
                const data = decodeSaveData(payload);
                const parentEl = document.getElementById("controls");
                // make sure the list is empty, it should be, but we can make sure easily enough.
                clear_loops();

                for (let i = 0; i < data.length; i++) {
                    const new_control = document.createElement("element-control-form");
                    new_control.initialData = data[i];
                    parentEl.appendChild(new_control);
                }
                update_drawing();
            }
        }
    </script>
</head>

<body onload="setup()">
    <div class="row">
        <div id="canvas_container" class="canvasContainer">
            <svg id="image_root" version="1.1" viewBox="0 0 400 400" with=100% height=100%
                xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg" stroke="black" fill="none"
                stroke-width="1px" stroke-opacity="1" fill-opacity="1">

            </svg>
        </div>
        <div id="controls_container" class="controlContainer">
            <div id="controls">

            </div>
            <div id="add_button" class="button" onclick="add_element()">
                Add Loop
            </div>
            <div id="save_button" class="button" onclick="download()">
                Download
            </div>
            <div id="clear_button" class="button" onclick="clear_loops()">
                Clear
            </div>
        </div>
    </div>
</body>

</html>